{"meta":{"title":"Mercidaiha","subtitle":"","description":"","author":"Wei Song","url":"https://mercidaiha.github.io","root":"/"},"pages":[{"title":"Wei Song","date":"2023-03-02T14:54:57.585Z","updated":"2023-03-02T14:54:57.585Z","comments":false,"path":"about/index.html","permalink":"https://mercidaiha.github.io/about/index.html","excerpt":"","text":"我是来自中国科学技术大学（USTC）计算机科学与技术学院的一名学生，目前就读大三。 研究兴趣：HCI (Human–Computer Interaction); Recommender Systems; AI + X(e.g. Education); XR; Data mining; 我目前正在寻找合适的暑期研究。我的邮箱是 sw2@mail.ustc.edu.cn I am a student from the School of Computer Science and Technology at the University of Science and Technology of China (USTC), currently in my junior year. My Research Experience: HCI (Human–Computer Interaction); Recommender Systems; AI + X(e.g. Education); XR; Data mining; I’m looking for summer research or internship (2023). If you are interested in me, please contact me at sw2@mail.ustc.edu.cn My CV"},{"title":"书单","date":"2022-02-05T15:22:01.110Z","updated":"2022-02-05T15:22:01.110Z","comments":false,"path":"books/index.html","permalink":"https://mercidaiha.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-02-08T08:42:34.261Z","updated":"2022-02-05T15:22:01.111Z","comments":false,"path":"categories/index.html","permalink":"https://mercidaiha.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-02-08T08:11:04.292Z","updated":"2022-02-05T15:22:01.113Z","comments":false,"path":"tags/index.html","permalink":"https://mercidaiha.github.io/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-02-05T16:07:33.000Z","updated":"2022-02-05T16:07:33.330Z","comments":true,"path":"archives/index.html","permalink":"https://mercidaiha.github.io/archives/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-02-05T15:22:01.112Z","updated":"2022-02-05T15:22:01.112Z","comments":false,"path":"repository/index.html","permalink":"https://mercidaiha.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-02-05T15:22:01.111Z","updated":"2022-02-05T15:22:01.111Z","comments":true,"path":"links/index.html","permalink":"https://mercidaiha.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"单周期CPU","slug":"单周期CPU","date":"2022-04-21T09:39:18.000Z","updated":"2022-04-21T09:41:24.039Z","comments":true,"path":"2022/04/21/单周期CPU/","link":"","permalink":"https://mercidaiha.github.io/2022/04/21/%E5%8D%95%E5%91%A8%E6%9C%9FCPU/","excerpt":"","text":"lab4 单周期CPU设计 姓名：宋玮 学号：PB20151793 实验日期：2022.4.21 实验题目 lab4 单周期CPU设计 实验目的 •理解CPU的结构和工作原理 •掌握单周期CPU的设计和调试方法 •熟练掌握数据通路和控制器的设计和描述方法 实验平台 Rars，fpgaol，vivado 实验过程 1.设计实现单周期RISC-V CPU （1）基本数据通路如下 当然，该数据通路适用于6条指令，若想用于10条指令，则需要： ①在Read_data1与pc间加一个mux用于完成auipc指令 ②在Branch，jal信号选择器前添加jalr_PC信号，用于完成jalr指令 ③sub指令通路与add指令基本一致 ④blt指令通路与beq指令基本一致，只需通过ALUop来区分两个指令 （2）CPU各模块 ①rf（寄存器堆） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758module rf#( parameter m=5,WIDTH=32)( input clk,we,rst, input [m-1:0] wa, input [m-1:0]ra0,ra1, input [WIDTH-1:0] wd, output [WIDTH-1:0] rd0,rd1, input [m-1:0] rf_addr, output [WIDTH-1:0] rf_data);parameter sum = 8&#x27;b1 &lt;&lt; m;reg [WIDTH-1:0] regfile [0:sum-1];assign rd0 = regfile[ra0], rd1 = regfile[ra1];assign rf_data = regfile[rf_addr];always @(posedge clk or posedge rst) begin if(rst) begin regfile[0] &lt;= 0; regfile[1] &lt;= 0; regfile[2] &lt;= 0; regfile[3] &lt;= 0; regfile[4] &lt;= 0; regfile[5] &lt;= 0; regfile[6] &lt;= 0; regfile[7] &lt;= 0; regfile[8] &lt;= 0; regfile[9] &lt;= 0; regfile[10] &lt;= 0; regfile[11] &lt;= 0; regfile[12] &lt;= 0; regfile[13] &lt;= 0; regfile[14] &lt;= 0; regfile[15] &lt;= 0; regfile[16] &lt;= 0; regfile[17] &lt;= 0; regfile[18] &lt;= 0; regfile[19] &lt;= 0; regfile[20] &lt;= 0; regfile[21] &lt;= 0; regfile[22] &lt;= 0; regfile[23] &lt;= 0; regfile[24] &lt;= 0; regfile[25] &lt;= 0; regfile[26] &lt;= 0; regfile[27] &lt;= 0; regfile[28] &lt;= 0; regfile[29] &lt;= 0; regfile[30] &lt;= 0; regfile[31] &lt;= 0; end else if (we &amp;&amp; wa!= 0) regfile[wa] &lt;= wd;endendmodule ②immg（立即数处理模块） 1234567891011121314151617181920212223242526module immg(input [31:0] ins,output reg [31:0] imm ); always @(*)begin case(ins[6:0]) 7&#x27;b0000011: begin imm = &#123;&#123;20&#123;ins[31]&#125;&#125;,ins[31:20]&#125;;//lw end 7&#x27;b0100011: begin imm = &#123;&#123;20&#123;ins[31]&#125;&#125;,ins[31:25],ins[11:7]&#125;; //sd end 7&#x27;b0010011: imm = &#123;&#123;20&#123;ins[31]&#125;&#125;,ins[31:20]&#125;;//addi 7&#x27;b1100011: imm = &#123;&#123;20&#123;ins[31]&#125;&#125;,ins[7],ins[30:25],ins[11:8],1&#x27;b0&#125;;//beq,blt 7&#x27;b1101111: imm = &#123;&#123;12&#123;ins[31]&#125;&#125;,ins[19:12],ins[20],ins[30:21],1&#x27;b0&#125;;//jal 7&#x27;b0010111: imm = &#123;ins[31:12],12&#x27;b0&#125;;//aauipc 7&#x27;b1100111: imm = &#123;&#123;20&#123;ins[31]&#125;&#125;,ins[31:20]&#125;;//jalr default: imm = 0; //add,sub endcaseendendmodule ③alu模块 12345678910111213141516171819202122232425262728293031module alu#( parameter WIDTH = 32)( input[WIDTH-1:0] a, input[WIDTH-1:0] b, input [31:0] ins, input [2:0] f, output reg [WIDTH-1:0] y, output z);wire signed [31:0] sa;wire signed [31:0] sb;assign sa = a;assign sb = b;always@(*)begin case(f) 3&#x27;b000: y = a + b; 3&#x27;b001: y = a - b; 3&#x27;b010: y = a &amp; b; 3&#x27;b011: y = a | b; 3&#x27;b100: y = a ^ b; 3&#x27;b101: y = (sa&gt;=sb); default: y = 0; endcaseend assign z = y ? 1&#x27;b0 : 1&#x27;b1;endmodule ④alu_control模块 12345678910111213module alu_control(input [1:0] aluop,output reg [2:0] sel);always@(*)begin case(aluop) 2&#x27;b01: sel = 3&#x27;b001; 2&#x27;b11: sel = 3&#x27;b101; default: sel = 3&#x27;b000; endcaseendendmodule ⑤control模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273module control(input [31:0] ins,output reg ALUSrc,RegWrite,MemRead,MemWrite,Branch,JUMP,jalr_PC,auipc,output reg [1:0] ALUOp, reg [1:0] MemtoReg ); always@(*)begin case(ins[6:0]) 7&#x27;b0110011: begin if(ins[31:25]==7&#x27;b0) //add begin ALUSrc = 0; MemtoReg = 2&#x27;b00; RegWrite = 1; MemRead = 0; MemWrite = 0; Branch = 0; JUMP = 0; ALUOp = 2&#x27;b10; auipc = 0; jalr_PC = 0; end else //sub begin ALUSrc = 0; MemtoReg = 2&#x27;b00; RegWrite = 1; MemRead = 0; MemWrite = 0; Branch = 0; JUMP = 0; ALUOp = 2&#x27;b01; auipc = 0; jalr_PC = 0; end end 7&#x27;b0000011: //lw begin ALUSrc = 1; MemtoReg = 2&#x27;b01; RegWrite = 1; MemRead = 1; MemWrite = 0; Branch = 0; JUMP = 0; ALUOp = 2&#x27;b00; auipc = 0; jalr_PC = 0; end 7&#x27;b0100011: //sw begin ALUSrc = 1; MemtoReg = 2&#x27;b00; RegWrite = 0; MemRead = 0; MemWrite = 1; Branch = 0; JUMP = 0; ALUOp = 2&#x27;b00; auipc = 0; jalr_PC = 0; end 7&#x27;b0010011: //addi begin ALUSrc = 1; MemtoReg = 2&#x27;b00; RegWrite = 1; MemRead = 0; MemWrite = 0; Branch = 0; JUMP = 0; ALUOp = 2&#x27;b10; auipc = 0; jalr_PC = 0; end 7&#x27;b1100011: // beq,blt begin if(ins[14:12]==3&#x27;b000) //beq begin ALUSrc = 0; MemtoReg = 0; RegWrite = 0; MemRead =0 ; MemWrite = 0; Branch = 1; JUMP = 0; ALUOp = 2&#x27;b01; auipc = 0; jalr_PC = 0; end else //blt begin ALUSrc = 0; MemtoReg = 0; RegWrite = 0; MemRead =0 ; MemWrite = 0; Branch = 1; JUMP = 0; ALUOp = 2&#x27;b11; auipc = 0; jalr_PC = 0; end end 7&#x27;b1101111: //jal begin ALUSrc = 0; MemtoReg = 2&#x27;b10; RegWrite = 1; MemRead =0 ; MemWrite = 0; Branch = 0; JUMP = 1; ALUOp = 2&#x27;b00; auipc = 0; jalr_PC = 0; end 7&#x27;b1100111://jalr begin ALUSrc = 1; MemtoReg = 2&#x27;b10; RegWrite = 1; MemRead =0 ; MemWrite = 0; Branch = 0; JUMP = 0; ALUOp = 2&#x27;b00; auipc = 0; jalr_PC = 1; end 7&#x27;b0010111: //auipc begin ALUSrc = 1; MemtoReg = 2&#x27;b00; RegWrite = 1; MemRead =0 ; MemWrite = 0; Branch = 0; JUMP = 0; ALUOp = 2&#x27;b10; auipc = 1; jalr_PC = 0; end default: begin ALUSrc = 0; MemtoReg = 2&#x27;b00; RegWrite = 0; MemRead =0 ; MemWrite = 0; Branch = 0; JUMP = 0; ALUOp = 2&#x27;b00; auipc = 0; jalr_PC = 0; end endcaseendendmodule ⑥data_memory &amp; ins_memory 分别使用两个分布式存储器ip核，并用对应的data.coe和ins.coe文件对其进行初始化； ⑦CPU主体模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384module cpu(input clk,rst, input [31:0] io_din, input [7:0] m_rf_addr , output [7:0] io_addr , output [31:0] io_dout , output io_we , output [31:0] rf_data, output [31:0] m_data , output reg [31:0] pc );wire Zero;wire Branch,MemRead,MemWrite,ALUSrc,RegWrite,JUMP,jalr_PC,auipc;wire MemWrite_true;wire [1:0] ALUOp ,MemtoReg;wire [31:0] ins, imm;wire [31:0] readData1,readData2,ALU_input2,ALU_input1;wire [31:0] Mem_ReadData, RF_writeData;wire [31:0] Mem_ReadData_waishe, Mem_ReadData_MEM;wire [31:0] nPC_4,PC_offset,PC_jalr,PC_mux;wire [31:0] nPC;wire which_PC;wire [31:0] ALU_result;reg [31:0] writeData;wire [2:0] sel;wire [31:0] io_addr1;wire [7:0] apc;ins_memory IMem(.a(apc),.spo(ins));data_memory DMem(.a(ALU_result[7:0]),.d(readData2),.dpra(m_rf_addr),.clk(clk),.we(MemWrite_true),.spo(Mem_ReadData_MEM),.dpo(m_data));control control(.ins(ins),.ALUSrc(ALUSrc),.RegWrite(RegWrite),.MemRead(MemRead),.MemWrite(MemWrite),.Branch(Branch),.JUMP(JUMP),.jalr_PC(jalr_PC),.auipc(auipc),.ALUOp(ALUOp), .MemtoReg(MemtoReg) );rf #(.m(5),.WIDTH(32)) rf (.clk(clk),.we(RegWrite), .wa(ins[11:7]),.ra0(ins[19:15]),.ra1(ins[24:20]), .wd(writeData),.rd0(readData1),.rd1(readData2), .rf_addr(m_rf_addr[4:0]), .rf_data(rf_data),.rst(rst)); immg immg(.ins(ins),.imm(imm));alu_control alu_control(.aluop(ALUOp),.sel(sel));alu # (32) alu(.a(ALU_input1),.b(ALU_input2),.ins(ins),.f(sel),.z(Zero),.y(ALU_result));assign PC_jalr = ALU_result &amp; (~32&#x27;b1); //jalr PCassign nPC_4 = pc + 4; //pc+4assign PC_offset = pc + imm; assign which_PC = (Branch &amp; Zero) | JUMP ;assign PC_mux = which_PC ? PC_offset : nPC_4;assign nPC = jalr_PC ? PC_jalr : PC_mux;assign ALU_input2 = ALUSrc ? imm : readData2;assign ALU_input1 = auipc ? pc : readData1;assign apc = pc[9:2];always@(posedge clk or posedge rst)begin if(rst) pc &lt;= 32&#x27;h0000_3000; else pc &lt;= nPC;end//register file writedataalways@(*)begin if((JUMP==0)||(jalr_PC==0)) begin if(MemtoReg==0) writeData = ALU_result; else writeData = Mem_ReadData; end else writeData = nPC_4 ;endassign io_addr1=ALU_result;assign io_addr = io_addr1[7:0];assign MemWrite_true = (~io_addr1[10]) &amp; MemWrite;assign Mem_ReadData_waishe = io_din;assign Mem_ReadData = io_addr1[10]? Mem_ReadData_waishe : Mem_ReadData_MEM;assign io_dout = readData2; assign io_we = io_addr1[10] &amp; MemWrite;endmodule 2.pdu模块（用于io） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163module pdu(input clk, input rst, //选择CPU工作方式; input run, input step, output clk_cpu, //输入switch的端口 input valid, input [4:0] in, //输出led和seg的端口 output [1:0] check, //led6-5:查看类型 output [4:0] out0, //led4-0 output [2:0] an, //8个数码管 output [3:0] seg, output ready, //led7 //IO_BUS input [7:0] io_addr, input [31:0] io_dout, input io_we, output [31:0] io_din, //Debug_BUS output [7:0] m_rf_addr, input [31:0] rf_data, input [31:0] m_data, input [31:0] pc);reg [4:0] in_r; //同步外部输入用reg run_r, step_r, step_2r, valid_r, valid_2r;wire step_p, valid_pn; //取边沿信号reg clk_cpu_r; //寄存器输出CPU时钟reg [4:0] out0_r; //输出外设端口reg [31:0] out1_r;reg ready_r;reg [19:0] cnt; //刷新计数器，刷新频率约为95Hzreg [1:0] check_r; //查看信息类型, 00-运行结果，01-寄存器堆，10-存储器，11-PCreg [7:0] io_din_a; //_a表示为满足组合always描述要求定义的，下同reg ready_a;reg [4:0] out0_a;reg [31:0] out1_a;reg [3:0] seg_a;assign clk_cpu = clk_cpu_r;assign io_din = io_din_a;assign check = check_r;assign out0 = out0_a;assign ready = ready_a;assign seg = seg_a;assign an = cnt[19:17];assign step_p = step_r &amp; ~step_2r; //取上升沿assign valid_pn = valid_r ^ valid_2r; //取上升沿或下降沿assign m_rf_addr = &#123;&#123;3&#123;1&#x27;b0&#125;&#125;, in_r&#125;;//同步输入信号always @(posedge clk) begin run_r &lt;= run; step_r &lt;= step; step_2r &lt;= step_r; valid_r &lt;= valid; valid_2r &lt;= valid_r; in_r &lt;= in; end//CPU工作方式always @(posedge clk, posedge rst) begin if(rst) clk_cpu_r &lt;= 0; else if (run_r) clk_cpu_r &lt;= ~clk_cpu_r; else clk_cpu_r &lt;= step_p;end//读外设端口always @* begin case (io_addr) 8&#x27;h0c: io_din_a = &#123;&#123;27&#123;1&#x27;b0&#125;&#125;, in_r&#125;; 8&#x27;h10: io_din_a = &#123;&#123;31&#123;1&#x27;b0&#125;&#125;, valid_r&#125;; default: io_din_a = 32&#x27;h0000_0000; endcaseend//写外设端口always @(posedge clk, posedge rst) beginif (rst) begin out0_r &lt;= 5&#x27;h1f; out1_r &lt;= 32&#x27;h1234_5678; ready_r &lt;= 1&#x27;b1;endelse if (io_we) case (io_addr) 8&#x27;h00: out0_r &lt;= io_dout[4:0]; 8&#x27;h04: ready_r &lt;= io_dout[0]; 8&#x27;h08: out1_r &lt;= io_dout; default: ; endcaseend//LED和数码管查看类型always @(posedge clk, posedge rst) beginif(rst) check_r &lt;= 2&#x27;b00; else if(run_r) check_r &lt;= 2&#x27;b00; else if (step_p) check_r &lt;= 2&#x27;b00; else if (valid_pn) check_r &lt;= check - 2&#x27;b01;end//LED和数码管显示内容always @* begin ready_a = 1&#x27;b0; case (check_r) 2&#x27;b00: begin out0_a = out0_r; out1_a = out1_r; ready_a = ready_r; end 2&#x27;b01: begin out0_a = in_r; out1_a = rf_data; end 2&#x27;b10: begin out0_a = in_r; out1_a = m_data; end 2&#x27;b11: begin out0_a = 5&#x27;b00000; out1_a = pc; end endcaseend//扫描数码管always @(posedge clk, posedge rst) begin if (rst) cnt &lt;= 20&#x27;h0_0000; else cnt &lt;= cnt + 20&#x27;h0_0001;endalways @* begin case (an) 3&#x27;d0: seg_a = out1_a[3:0]; 3&#x27;d1: seg_a = out1_a[7:4]; 3&#x27;d2: seg_a = out1_a[11:8]; 3&#x27;d3: seg_a = out1_a[15:12]; 3&#x27;d4: seg_a = out1_a[19:16]; 3&#x27;d5: seg_a = out1_a[23:20]; 3&#x27;d6: seg_a = out1_a[27:24]; 3&#x27;d7: seg_a = out1_a[31:28]; default: ; endcaseendendmodule （1）外设使用说明： （2）存储器配置： 3.10条指令测试汇编程序以及仿真 （1）汇编程序 123456789101112131415161718192021222324252627282930.data0x4000xfe .textlw t3, 0(x0)sw x0, 8(t3) #test swaddi t0, x0, 0xff #test addisw t0, 8(t3)lw t0, 4(x0) #test lwsw t0, 8(t3) addi t1,x0,1 add t0,t1,t0 #test addsw t0, 8(t3) #t0=t0+t1sub t0,t0,t1 #t0=t0-t1, test subsw t0, 8(t3) addi t2,x0,1auipc t1,0 #test auipcloop1:blt t2,x0,be #test bltaddi t2,t2,-1sw t2, 8(t3)jalr x1,t1,4 #test jalrbe: addi t2,x0,1 loop:beq t2,x0,exit #test beqaddi t2,t2,-1sw t2, 8(t3)jal x1,loop #test jalexit: （2）仿真文件 123456789101112131415161718module cpu_sim();reg clk;reg rst; reg [31:0] io_din; reg [7:0] m_rf_addr; initial clk = 0;always #5 clk = ~clk;initial rst = 1;initial #10 rst = 0;initial m_rf_addr = 1;initial io_din = 0;initial #300 $stop;cpu cpu1(.clk(clk),.rst(rst),.m_rf_addr(m_rf_addr),.io_din(io_din));endmodule （3）仿真截图 从图中可以看到pc，ins，regfile等值的变化，可验证该执行流程是正确的。 4.10条指令上板测试（fpga平台） 图1,2,3中显示均为pc值，图4显示为某一步的read_data2值 5.fib仿真 （1）仿真文件 1234567891011121314151617181920212223242526272829module top_sim( ); reg clk,rst,run,valid,step;reg [4:0] in;wire [1:0]check;wire [4:0] out0;wire [2:0] an; wire [3:0] seg;wire ready;top top1(.clk(clk),.rst(rst),.run(run),.valid(valid),.step(step),.in(in),.check(check),.out0(out0),.an(an),.seg(seg),.ready(ready));initial clk = 0;always #4 clk = ~clk;initial valid = 0;always #7 valid = ~valid;initialbegin rst = 1;run = 0; in = 0; step = 0; #20 rst = 0; #2 run=1; #5 in = 1; #250 in = 2; #600 $finish;endendmodule （2）仿真截图 输入前两项为1和2，后面自动输出3，5，8 …… 6.fib上板（fpga平台测试）","categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://mercidaiha.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"cs","slug":"cs","permalink":"https://mercidaiha.github.io/tags/cs/"},{"name":"计组","slug":"计组","permalink":"https://mercidaiha.github.io/tags/%E8%AE%A1%E7%BB%84/"}]},{"title":"part 7-2","slug":"part-7-2","date":"2022-04-20T06:09:41.000Z","updated":"2022-04-20T06:12:47.855Z","comments":true,"path":"2022/04/20/part-7-2/","link":"","permalink":"https://mercidaiha.github.io/2022/04/20/part-7-2/","excerpt":"","text":"VM(虚拟内存) cpu执行过程：所有进程(虚拟地址) 地址转换？虚拟与物理地址 连续空间分配：动态增长？进程大小 MMU实现 目标：地址翻译 -&gt; 查找表 -&gt; 空间开销太大-&gt; 减少映射条目（从虚拟地址映射到物理地址） 思想：粗粒度映射 一块地址范围建一个映射 ​ 4k（12bits）是一个page -&gt; 分页 -&gt; 页表（逻辑页到物理页映射）","categories":[{"name":"os2022","slug":"os2022","permalink":"https://mercidaiha.github.io/categories/os2022/"}],"tags":[{"name":"operating system","slug":"operating-system","permalink":"https://mercidaiha.github.io/tags/operating-system/"},{"name":"cs","slug":"cs","permalink":"https://mercidaiha.github.io/tags/cs/"}]},{"title":"概统（1）","slug":"概统（1）","date":"2022-02-06T07:40:31.000Z","updated":"2022-02-08T12:47:37.757Z","comments":true,"path":"2022/02/06/概统（1）/","link":"","permalink":"https://mercidaiha.github.io/2022/02/06/%E6%A6%82%E7%BB%9F%EF%BC%881%EF%BC%89/","excerpt":"","text":"基本概念 基本事件：随机试验中的每个单一结果 随机事件：简称事件，在随机试验中我们所关心的可能出现的各种结果，它由一个或若干个基本事件组成. ps:随机事件常用大写英文字母A,B,C,D等表示. 如果用语言表达，则要用花括号括起来. 样本空间：随机试验中所有基本事件所构成的集合，通常用Ω\\OmegaΩ或SSS表示 必然事件（Ω\\OmegaΩ）：在试验中一定会发生的事件； 不可能事件（Φ\\PhiΦ)：在试验中不可能发生的事件","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://mercidaiha.github.io/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"statistic","slug":"statistic","permalink":"https://mercidaiha.github.io/tags/statistic/"},{"name":"math","slug":"math","permalink":"https://mercidaiha.github.io/tags/math/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-02-05T15:08:23.090Z","updated":"2022-02-05T15:08:23.090Z","comments":true,"path":"2022/02/05/hello-world/","link":"","permalink":"https://mercidaiha.github.io/2022/02/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://mercidaiha.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"os2022","slug":"os2022","permalink":"https://mercidaiha.github.io/categories/os2022/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://mercidaiha.github.io/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"cs","slug":"cs","permalink":"https://mercidaiha.github.io/tags/cs/"},{"name":"计组","slug":"计组","permalink":"https://mercidaiha.github.io/tags/%E8%AE%A1%E7%BB%84/"},{"name":"operating system","slug":"operating-system","permalink":"https://mercidaiha.github.io/tags/operating-system/"},{"name":"statistic","slug":"statistic","permalink":"https://mercidaiha.github.io/tags/statistic/"},{"name":"math","slug":"math","permalink":"https://mercidaiha.github.io/tags/math/"}]}